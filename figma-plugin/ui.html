<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Open H2D Importer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 12px;
      color: #333;
      line-height: 1.4;
    }

    .container {
      width: 360px;
      min-height: 400px;
      display: flex;
      flex-direction: column;
    }

    .header {
      padding: 16px;
      border-bottom: 1px solid #e5e5e5;
      background: #f8f8f8;
    }

    .title {
      font-size: 14px;
      font-weight: 600;
      color: #333;
      margin-bottom: 4px;
    }

    .subtitle {
      font-size: 11px;
      color: #666;
    }

    .content {
      flex: 1;
      padding: 16px;
    }

    .drop-zone {
      border: 2px dashed #d0d0d0;
      border-radius: 8px;
      padding: 32px 16px;
      text-align: center;
      transition: all 0.2s ease;
      cursor: pointer;
      background: #fafafa;
      position: relative;
      min-height: 160px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .drop-zone:hover {
      border-color: #18a0fb;
      background: #f0f8ff;
    }

    .drop-zone.drag-over {
      border-color: #18a0fb;
      background: #e8f4ff;
      border-style: solid;
    }

    .drop-zone.processing {
      border-color: #ffa500;
      background: #fff8e1;
      cursor: wait;
    }

    .drop-icon {
      width: 48px;
      height: 48px;
      margin-bottom: 16px;
      opacity: 0.6;
    }

    .drop-text {
      font-size: 14px;
      color: #333;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .drop-subtext {
      font-size: 11px;
      color: #666;
      max-width: 280px;
      line-height: 1.3;
    }

    .file-input {
      display: none;
    }

    .progress-container {
      display: none;
      margin-top: 16px;
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: #e5e5e5;
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .progress-fill {
      height: 100%;
      background: #18a0fb;
      transition: width 0.3s ease;
      width: 0%;
    }

    .progress-text {
      font-size: 11px;
      color: #666;
      text-align: center;
    }

    .error-container {
      display: none;
      margin-top: 16px;
      padding: 12px;
      background: #ffe8e8;
      border: 1px solid #ffcccc;
      border-radius: 4px;
    }

    .error-title {
      font-size: 12px;
      font-weight: 600;
      color: #d32f2f;
      margin-bottom: 4px;
    }

    .error-message {
      font-size: 11px;
      color: #d32f2f;
      line-height: 1.3;
    }

    .success-container {
      display: none;
      margin-top: 16px;
      padding: 12px;
      background: #e8f5e8;
      border: 1px solid #c8e6c9;
      border-radius: 4px;
    }

    .success-title {
      font-size: 12px;
      font-weight: 600;
      color: #2e7d32;
      margin-bottom: 4px;
    }

    .success-message {
      font-size: 11px;
      color: #2e7d32;
      line-height: 1.3;
    }

    .import-button {
      width: 100%;
      padding: 12px;
      background: #18a0fb;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 16px;
      transition: background 0.2s ease;
    }

    .import-button:hover {
      background: #1591ea;
    }

    .import-button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .file-info {
      display: none;
      margin-top: 16px;
      padding: 12px;
      background: #f0f8ff;
      border: 1px solid #d0e8ff;
      border-radius: 4px;
    }

    .file-name {
      font-size: 12px;
      font-weight: 600;
      color: #333;
      margin-bottom: 4px;
    }

    .file-details {
      font-size: 11px;
      color: #666;
    }

    .settings {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #e5e5e5;
    }

    .setting-item {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
    }

    .setting-checkbox {
      margin-right: 8px;
    }

    .setting-label {
      font-size: 11px;
      color: #333;
      flex: 1;
    }

    .validation-list {
      margin-top: 8px;
    }

    .validation-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
      font-size: 11px;
    }

    .validation-icon {
      width: 12px;
      height: 12px;
      margin-right: 6px;
      border-radius: 50%;
      display: inline-block;
    }

    .validation-icon.success {
      background: #4caf50;
    }

    .validation-icon.error {
      background: #f44336;
    }

    .validation-icon.pending {
      background: #ff9800;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="title">Open H2D Importer</div>
      <div class="subtitle">Import web pages captured by the Open H2D Chrome extension</div>
    </div>

    <div class="content">
      <div class="drop-zone" id="dropZone">
        <svg class="drop-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <polyline points="14,2 14,8 20,8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <line x1="16" y1="13" x2="8" y2="13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <line x1="16" y1="17" x2="8" y2="17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <polyline points="10,9 9,9 8,9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <div class="drop-text">Drop ZIP file here</div>
        <div class="drop-subtext">Or click to select a .zip file exported from the Open H2D Chrome extension</div>
      </div>

      <input type="file" id="fileInput" class="file-input" accept=".zip" />

      <div class="file-info" id="fileInfo">
        <div class="file-name" id="fileName"></div>
        <div class="file-details" id="fileDetails"></div>
        <div class="validation-list" id="validationList"></div>
      </div>

      <div class="progress-container" id="progressContainer">
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text" id="progressText">Initializing...</div>
      </div>

      <div class="error-container" id="errorContainer">
        <div class="error-title">Import Failed</div>
        <div class="error-message" id="errorMessage"></div>
      </div>

      <div class="success-container" id="successContainer">
        <div class="success-title">Import Successful</div>
        <div class="success-message" id="successMessage"></div>
      </div>

      <button class="import-button" id="importButton" disabled>Import Page</button>

      <div class="settings">
        <div class="setting-item">
          <input type="checkbox" id="pixelPerfectMode" class="setting-checkbox" checked>
          <label for="pixelPerfectMode" class="setting-label">Pixel-perfect mode (prioritize fidelity over performance)</label>
        </div>
        <div class="setting-item">
          <input type="checkbox" id="useAutoLayout" class="setting-checkbox" checked>
          <label for="useAutoLayout" class="setting-label">Use auto-layout where possible</label>
        </div>
        <div class="setting-item">
          <input type="checkbox" id="groupSimilar" class="setting-checkbox">
          <label for="groupSimilar" class="setting-label">Group similar elements automatically</label>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Inline fflate library to avoid CDN issues
    window.fflate=function(){"use strict";var t=Uint8Array,r=Uint16Array,e=Int32Array,n=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),o=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),i=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),a=function(t,n){for(var o=new r(31),i=0;i<31;++i)o[i]=n+=1<<t[i-1];var a=new e(o[30]);for(i=1;i<30;++i)for(var s=o[i];s<o[i+1];++s)a[s]=s-o[i]<<5|i;return{b:o,r:a}},s=a(n,2),u=s.b,h=s.r;u[28]=258,h[258]=28;for(var f=a(o,0),c=f.b,l=f.r,p=new r(32768),v=0;v<32768;++v){var d=(43690&v)>>1|(21845&v)<<1;p[v]=((65280&(d=(61680&(d=(52428&d)>>2|(13107&d)<<2))>>4|(3855&d)<<4))>>8|(255&d)<<8)>>1}var g=function(e,n,o){for(var i=e.length,a=0,s=new r(n);a<i;++a)e[a]&&++s[e[a]-1];var u,h=new r(n);for(a=1;a<n;++a)h[a]=h[a-1]+s[a-1]<<1;if(o){u=new r(1<<n);var f=15-n;for(a=0;a<i;++a)if(e[a])for(var c=a<<4|e[a],l=n-e[a],v=h[e[a]-1]++<<l,d=v|(1<<l)-1;v<=d;++v)u[p[v]>>f]=c}else for(u=new r(i),a=0;a<i;++a)e[a]&&(u[a]=p[h[e[a]-1]++]>>15-e[a]);return u},m=new t(288);for(v=0;v<144;++v)m[v]=8;for(v=144;v<256;++v)m[v]=9;for(v=256;v<280;++v)m[v]=7;for(v=280;v<288;++v)m[v]=8;var y=g(m,9,1),b=g(new t([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]),5,1),w=function(t,r){var e=r/8|0;return(t[e]|t[e+1]<<8)>>(7&r)&((1<<31&31)-1)},x=function(t,r,e){var n=r/8|0;return(t[n]|t[n+1]<<8|t[n+2]<<16)>>(7&r)&((1<<e)-1)},z=function(t){return(t+7)/8|0},k=function(e,n,o){return(null==n||n<0)&&(n=0),(null==o||o>e.length)&&(o=e.length),new t(e.subarray(n,o))};function A(t,r,e,n,o){return function(t,r,e,n,o,i){var a=t.length,s=i?i.length:0;if(!a||r.f&&!r.l)return e||new Uint8Array(0);var u=!e,h=u||2!=r.i,f=r.i;u&&(e=new Uint8Array(3*a));var c=function(t){var r=e.length;if(t>r){var n=new Uint8Array(Math.max(2*r,t));n.set(e),e=n}},l=r.f||0,p=r.p||0,v=r.b||0,d=r.l,g=r.d,m=r.m,A=r.n,S=8*a;do{if(!d){l=w(t,p,1);var E=w(t,p+1,3);if(p+=3,!E){var M=t[(O=z(p)+4)-4]|t[O-3]<<8,T=O+M;if(T>a){f&&(0,0);break}h&&c(v+M),e.set(t.subarray(O,T),v),r.b=v+=M,r.p=p=8*T,r.f=l;continue}if(1==E)d=y,g=b,m=9,A=5;else if(2==E){var C=w(t,p,31)+257,U=w(t,p+10,15)+4,j=C+w(t,p+5,31)+1;p+=14;for(var R=new Uint8Array(j),_=new Uint8Array(19),D=0;D<U;++D)_[i[D]]=w(t,p+3*D,7);p+=3*U;var F=Math.max.apply(Math,_),G=(1<<F)-1,I=g(_, F,1);for(D=0;D<j;){var L,B=I[w(t,p,G)];if(p+=15&B,(L=B>>4)<16)R[D++]=L;else{var N=0,P=0;for(16==L?(P=3+w(t,p,3),p+=2,N=R[D-1]):17==L?(P=3+w(t,p,7),p+=3):18==L&&(P=11+w(t,p,127),p+=7);P--;)R[D++]=N}}var q=R.subarray(0,C),H=R.subarray(C);m=Math.max.apply(Math,q),A=Math.max.apply(Math,H),d=g(q,m,1),g=g(H,A,1)}else(0,0);if(p>S){f&&(0,0);break}}h&&c(v+131072);for(var J=(1<<m)-1,K=(1<<A)-1,Q=p;;Q=p){N=(L=d[x(t,p)&J])>>4;if((p+=15&L)>S){f&&(0,0);break}if(L||(0,0),N<256)e[v++]=N;else{if(256==N){Q=p,d=null;break}var V=N-254;N>264&&(V=w(t,p,(1<<(Y=n[W=N-257]))-1)+u[W],p+=Y);var W,X=g[x(t,p)&K],Y=X>>4;if(X||(0,0),p+=15&X,H=c[Y],Y>3){var Z=o[Y];H+=x(t,p)&(1<<Z)-1,p+=Z}if(p>S){f&&(0,0);break}h&&c(v+131072);var $=v+V;if(v<H){var tt=s-H,rt=Math.min(H,$);for(tt+v<0&&(0,0);v<rt;++v)e[v]=i[tt+v]}for(;v<$;++v)e[v]=e[v-H]}}r.l=d,r.p=Q,r.b=v,r.f=l,d&&(l=1,r.m=m,r.d=g,r.n=A)}while(!l);return v!=e.length&&u?k(e,0,v):e.subarray(0,v)}(t,r,e,n,o)}function S(){return{b:0,f:0,i:0,l:null,m:null,d:null,n:null,p:null}}function E(r){return r instanceof t?new t(r):r}var M=function(){try{return new TextDecoder}catch(t){}}(),T=0;try{M.decode(new t([97,115,100,102]),{stream:!0}),T=1}catch(r){}return{unzipSync:function(r,e){var n=e||{},o=E(r);if(o[0]!=80||o[1]!=75)throw"invalid zip file";for(var i={},a=o.length-22;a>=0&&(o[a]!=80||o[a+1]!=75||o[a+2]!=5||o[a+3]!=6);--a);if(a<0)throw"invalid zip file";var s=function(t,r,e){var n=t[r],o=t[r+1],i=t[r+2],a=t[r+3];return n|o<<8|i<<16|a<<24},u=s(o,a+16);if(u){var h=s(o,a+12);if(s(o,a+4)||s(o,a+6)!=s(o,a+8))throw"multi-disk zips are not supported";for(var f=0;f<u;++f){var c=h+46*f,l=s(o,c+42),p=s(o,c+32),v=s(o,c+28),d=s(o,c+24);if(o[c]!=80||o[c+1]!=75||o[c+2]!=1||o[c+3]!=2)throw"invalid zip file";var g,m,y=14&s(o,c+8),b=s(o,c+30),w=o.subarray(l+30+b,l+30+b+p);try{g=k(o,l+30+b+p+v,l+30+b+p+v+d)}catch(t){throw"invalid zip file"}if(y)if(8==y){var x=s(o,l+14),z=s(o,l+18),C=new t(z);try{A(w,S(),C,x,void 0)}catch(t){throw"invalid zip file"}m=C}else throw"unknown compression type "+y;else m=w;var U=function(t,r){if(r){for(var e="",n=0;n<t.length;n+=16384)e+=String.fromCharCode.apply(null,t.subarray(n,n+16384));return e}if(M){if(T)return M.decode(t);var o=M.decode(t,{stream:!0});return o+M.decode()}var i="";for(n=0;n<t.length;++n)i+=String.fromCharCode(t[n]);return i}(k(o,c+46,c+46+s(o,c+28)),!(2048&s(o,c+8)));i[U]=m}}return i}}}();

    // UI State Management
    let currentFile = null;
    let parsedData = null;
    let importSettings = {
      pixelPerfectMode: true,
      useAutoLayout: true,
      groupSimilar: false
    };

    // DOM Elements
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const fileInfo = document.getElementById('fileInfo');
    const fileName = document.getElementById('fileName');
    const fileDetails = document.getElementById('fileDetails');
    const validationList = document.getElementById('validationList');
    const progressContainer = document.getElementById('progressContainer');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    const errorContainer = document.getElementById('errorContainer');
    const errorMessage = document.getElementById('errorMessage');
    const successContainer = document.getElementById('successContainer');
    const successMessage = document.getElementById('successMessage');
    const importButton = document.getElementById('importButton');

    // Settings elements
    const pixelPerfectMode = document.getElementById('pixelPerfectMode');
    const useAutoLayout = document.getElementById('useAutoLayout');
    const groupSimilar = document.getElementById('groupSimilar');

    // Event Listeners
    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', handleDragOver);
    dropZone.addEventListener('dragleave', handleDragLeave);
    dropZone.addEventListener('drop', handleDrop);
    fileInput.addEventListener('change', handleFileSelect);
    importButton.addEventListener('click', handleImport);

    // Settings change handlers
    pixelPerfectMode.addEventListener('change', (e) => {
      importSettings.pixelPerfectMode = e.target.checked;
    });
    useAutoLayout.addEventListener('change', (e) => {
      importSettings.useAutoLayout = e.target.checked;
    });
    groupSimilar.addEventListener('change', (e) => {
      importSettings.groupSimilar = e.target.checked;
    });

    function handleDragOver(e) {
      e.preventDefault();
      dropZone.classList.add('drag-over');
    }

    function handleDragLeave(e) {
      e.preventDefault();
      dropZone.classList.remove('drag-over');
    }

    function handleDrop(e) {
      e.preventDefault();
      dropZone.classList.remove('drag-over');
      
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        processFile(files[0]);
      }
    }

    function handleFileSelect(e) {
      if (e.target.files.length > 0) {
        processFile(e.target.files[0]);
      }
    }

    function showError(title, message) {
      hideAllMessages();
      errorContainer.style.display = 'block';
      errorMessage.textContent = message;
    }

    function showSuccess(message) {
      hideAllMessages();
      successContainer.style.display = 'block';
      successMessage.textContent = message;
    }

    function showProgress(percent, text) {
      progressContainer.style.display = 'block';
      progressFill.style.width = percent + '%';
      progressText.textContent = text;
    }

    function hideProgress() {
      progressContainer.style.display = 'none';
    }

    function hideAllMessages() {
      errorContainer.style.display = 'none';
      successContainer.style.display = 'none';
    }

    function addValidationItem(text, success, pending = false) {
      const item = document.createElement('div');
      item.className = 'validation-item';
      
      const icon = document.createElement('span');
      icon.className = `validation-icon ${pending ? 'pending' : (success ? 'success' : 'error')}`;
      
      const textSpan = document.createElement('span');
      textSpan.textContent = text;
      
      item.appendChild(icon);
      item.appendChild(textSpan);
      validationList.appendChild(item);
      
      return item;
    }

    function clearValidationList() {
      validationList.innerHTML = '';
    }

    // Manual ZIP parsing fallback for files that fflate can't handle
    async function parseZipManually(arrayBuffer) {
      const data = new Uint8Array(arrayBuffer);
      const view = new DataView(arrayBuffer);
      const files = {};
      
      // Find the end of central directory record
      let eocdOffset = -1;
      for (let i = data.length - 22; i >= 0; i--) {
        if (view.getUint32(i, true) === 0x06054b50) {
          eocdOffset = i;
          break;
        }
      }
      
      if (eocdOffset === -1) {
        throw new Error('Not a valid ZIP file');
      }
      
      // Read central directory info
      const totalEntries = view.getUint16(eocdOffset + 10, true);
      const centralDirSize = view.getUint32(eocdOffset + 12, true);
      const centralDirOffset = view.getUint32(eocdOffset + 16, true);
      
      console.log('Manual ZIP parsing:', { totalEntries, centralDirSize, centralDirOffset });
      
      // Parse central directory entries
      let offset = centralDirOffset;
      for (let i = 0; i < totalEntries; i++) {
        if (view.getUint32(offset, true) !== 0x02014b50) {
          throw new Error('Invalid central directory entry');
        }
        
        const compressedSize = view.getUint32(offset + 20, true);
        const uncompressedSize = view.getUint32(offset + 24, true);
        const filenameLength = view.getUint16(offset + 28, true);
        const extraFieldLength = view.getUint16(offset + 30, true);
        const commentLength = view.getUint16(offset + 32, true);
        const localHeaderOffset = view.getUint32(offset + 42, true);
        
        // Read filename
        const filenameBytes = data.slice(offset + 46, offset + 46 + filenameLength);
        const filename = new TextDecoder().decode(filenameBytes);
        
        // Read file data from local header
        const localHeaderStart = localHeaderOffset;
        if (view.getUint32(localHeaderStart, true) !== 0x04034b50) {
          throw new Error('Invalid local file header');
        }
        
        const localFilenameLength = view.getUint16(localHeaderStart + 26, true);
        const localExtraLength = view.getUint16(localHeaderStart + 28, true);
        const fileDataStart = localHeaderStart + 30 + localFilenameLength + localExtraLength;
        const fileData = data.slice(fileDataStart, fileDataStart + compressedSize);
        
        files[filename] = fileData;
        
        // Move to next central directory entry
        offset += 46 + filenameLength + extraFieldLength + commentLength;
      }
      
      console.log('Manual parsing extracted files:', Object.keys(files));
      return files;
    }

    async function processFile(file) {
      if (!file.name.toLowerCase().endsWith('.zip')) {
        showError('Invalid File', 'Please select a ZIP file exported from the Open H2D Chrome extension.');
        return;
      }

      currentFile = file;
      hideAllMessages();
      
      // Show file info
      fileInfo.style.display = 'block';
      fileName.textContent = file.name;
      fileDetails.textContent = `Size: ${(file.size / 1024).toFixed(1)} KB`;
      clearValidationList();

      // Start validation
      dropZone.classList.add('processing');
      importButton.disabled = true;

      let zipData = null;

      try {
        showProgress(10, 'Reading ZIP file...');
        
        // Read and parse ZIP
        const arrayBuffer = await file.arrayBuffer();
        
        try {
          zipData = fflate.unzipSync(new Uint8Array(arrayBuffer));
        } catch (zipError) {
          console.error('fflate ZIP parsing error:', zipError);
          
          // Try alternative parsing approach for ZIP files that fflate can't handle
          if (zipError.toString().includes('multi-disk')) {
            console.log('Attempting alternative ZIP parsing...');
            try {
              // Try to parse as a simple ZIP manually
              zipData = await parseZipManually(arrayBuffer);
              console.log('Alternative parsing successful');
            } catch (manualError) {
              console.error('Manual parsing also failed:', manualError);
              throw new Error('This ZIP file format is not supported. Please ensure your Chrome extension creates standard ZIP files.');
            }
          } else if (zipError.toString().includes('invalid zip')) {
            throw new Error('Invalid ZIP file format. Please verify the file was created by the Open H2D Chrome extension.');
          } else {
            throw new Error(`ZIP parsing failed: ${zipError.message || zipError}`);
          }
        }

        showProgress(30, 'Validating structure...');
        
        // Debug: Log ZIP contents
        console.log('ZIP file contents:', Object.keys(zipData));
        console.log('ZIP file size:', Object.keys(zipData).length, 'files');
        
        // Validate ZIP structure
        const validation = await validateZipStructure(zipData);
        
        if (validation.isValid) {
          showProgress(60, 'Parsing page data...');
          parsedData = await parseZipData(zipData);
          
          showProgress(80, 'Validating elements...');
          // Additional validation
          const elementCount = parsedData.data.elements ? parsedData.data.elements.length : 0;
          const assetCount = parsedData.data.assets ? Object.keys(parsedData.data.assets).length : 0;
          
          addValidationItem(`Found ${elementCount} elements`, true);
          addValidationItem(`Found ${assetCount} assets`, true);
          
          showProgress(100, 'Ready to import');
          setTimeout(() => {
            hideProgress();
            importButton.disabled = false;
            showSuccess(`ZIP file validated successfully. Ready to import ${elementCount} elements.`);
          }, 500);
        } else {
          throw new Error(validation.error);
        }
        
      } catch (error) {
        console.error('File processing error:', error);
        showError('Validation Failed', error.message);
        addValidationItem('ZIP structure validation failed', false);
        
        // Log more details for debugging
        if (zipData) {
          console.log('ZIP contents:', Object.keys(zipData));
          if (zipData['manifest.json']) {
            try {
              const manifestText = new TextDecoder().decode(zipData['manifest.json']);
              console.log('Manifest content:', manifestText);
            } catch (e) {
              console.log('Could not decode manifest:', e);
            }
          }
        } else {
          console.log('ZIP data was not successfully parsed');
        }
      } finally {
        dropZone.classList.remove('processing');
      }
    }

    async function validateZipStructure(zipData) {
      const requiredFiles = ['manifest.json', 'data.json'];
      const validation = {
        isValid: true,
        error: null
      };

      // Check required files
      for (const file of requiredFiles) {
        if (!zipData[file]) {
          validation.isValid = false;
          validation.error = `Missing required file: ${file}`;
          addValidationItem(`Missing ${file}`, false);
          return validation;
        } else {
          addValidationItem(`Found ${file}`, true);
        }
      }

      try {
        // Parse and validate manifest
        const manifestText = new TextDecoder().decode(zipData['manifest.json']);
        const manifest = JSON.parse(manifestText);
        
        console.log('Manifest content:', manifest);
        console.log('Expected formats: zip-pack or h2d, got:', manifest.format);
        
        // Accept both 'zip-pack' and 'h2d' formats for compatibility
        if (manifest.format !== 'zip-pack' && manifest.format !== 'h2d') {
          validation.isValid = false;
          validation.error = `Invalid format: ${manifest.format}. Expected 'zip-pack' or 'h2d'.`;
          addValidationItem('Invalid manifest format', false);
          return validation;
        }
        addValidationItem('Valid manifest format', true);

        // Parse and validate data.json
        const dataText = new TextDecoder().decode(zipData['data.json']);
        const data = JSON.parse(dataText);
        
        console.log('Data structure:', {
          hasElements: !!data.elements,
          elementsLength: data.elements ? data.elements.length : 0,
          hasViewport: !!data.viewport,
          title: data.title
        });
        
        if (!data.elements || !Array.isArray(data.elements)) {
          validation.isValid = false;
          validation.error = 'Invalid data.json: missing or invalid elements array';
          addValidationItem('Invalid data structure', false);
          return validation;
        }
        addValidationItem('Valid data structure', true);

        // Check for assets directory
        const hasAssets = Object.keys(zipData).some(path => path.startsWith('assets/'));
        addValidationItem(`Assets directory ${hasAssets ? 'found' : 'not found'}`, hasAssets, !hasAssets);

      } catch (parseError) {
        console.error('JSON parsing error:', parseError);
        validation.isValid = false;
        validation.error = `JSON parsing error: ${parseError.message}`;
        addValidationItem('JSON parsing failed', false);
      }

      return validation;
    }

    async function parseZipData(zipData) {
      const manifestText = new TextDecoder().decode(zipData['manifest.json']);
      const dataText = new TextDecoder().decode(zipData['data.json']);
      
      const manifest = JSON.parse(manifestText);
      const data = JSON.parse(dataText);
      
      // Extract assets
      const assets = {};
      for (const [path, content] of Object.entries(zipData)) {
        if (path.startsWith('assets/')) {
          assets[path] = content;
        }
      }

      return {
        manifest,
        data,
        assets
      };
    }

    async function handleImport() {
      if (!parsedData) {
        showError('No Data', 'Please select and validate a ZIP file first.');
        return;
      }

      importButton.disabled = true;
      showProgress(0, 'Starting import...');

      try {
        // Send data to plugin code
        parent.postMessage({
          pluginMessage: {
            type: 'import',
            data: parsedData,
            settings: importSettings
          }
        }, '*');

      } catch (error) {
        console.error('Import error:', error);
        showError('Import Failed', error.message);
        importButton.disabled = false;
      }
    }

    // Listen for messages from plugin code
    window.addEventListener('message', (event) => {
      const { type, data } = event.data.pluginMessage || {};
      
      switch (type) {
        case 'import-progress':
          showProgress(data.percent, data.message);
          break;
          
        case 'import-success':
          hideProgress();
          showSuccess(data.message);
          importButton.disabled = false;
          break;
          
        case 'import-error':
          hideProgress();
          showError('Import Failed', data.message);
          importButton.disabled = false;
          break;
      }
    });
  </script>
</body>
</html>